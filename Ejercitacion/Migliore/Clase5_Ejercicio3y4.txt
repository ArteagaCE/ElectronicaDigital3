/*
 * Copyright 2022 NXP
 * NXP confidential.
 * This software is owned or controlled by NXP and may only be used strictly
 * in accordance with the applicable license terms.  By expressly accepting
 * such terms or by downloading, installing, activating and/or otherwise using
 * the software, you are agreeing that you have read, and that you agree to
 * comply with and are bound by, such license terms.  If you do not agree to
 * be bound by the applicable license terms, then you may not retain, install,
 * activate or otherwise use the software.
 */
/*----------------------------------------------------------------------------
 * Ejercicio 3:
 * Escrbir un programa para que cada persión de pulsador, la frecuencia de parpadeo
 * de un led disminuya a la mitad debido a la podificación del prescaler del Timer 2.
 *  El pulsador debe producir una interrupción por EINT1 con el flanco descendiente.
 *
 *  Ejercicio 4:
 *  Escribir un programa para que por cada presión de un pulsador, la
 *  frecuencia de parpadeo disminuya a la mitad debido a la modificación
 *	del registro del Match 0. El pulsador debe producir una interrupción por
 *	EINT2 con flanco descendente. (usé el EINT0 para usar el LedRGB VERDE y el
 *	SW2 con pulsador)
 * ----------------------------------------------------------------------------
 * */
#ifdef __USE_CMSIS
#include "LPC17xx.h"
#endif

#include <cr_section_macros.h>

// TODO: insert other include files here
#include "lpc17xx_gpio.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_pinsel.h"


//Prototipos de las funciones
void cfgGPIO(void);
//int cfgTimer0(uint32_t y);
int cfgTimer0(void);
int cfgTimer2(uint32_t x);
void cfgExtInt0(void);
void cfgExtInt1(void);

// TODO: insert other definitions and declarations here
#define CANAL_MATCH_0 (uint8_t) 0

uint32_t BaseDeTiempo=1000;

int main(void) {

	cfgGPIO();
	//cfgTimer0(MatchActual);
	cfgTimer0();
	cfgTimer2(BaseDeTiempo);
	cfgExtInt0();
	cfgExtInt1();

    while(1) {

    }
    return 0 ;
}

void cfgGPIO(void){

	//Configuro un pin P3.25 como de MATCH0[0]

		PINSEL_CFG_Type cfgPin1_28;

		cfgPin1_28.Portnum = PINSEL_PORT_1;
		cfgPin1_28.Pinnum = PINSEL_PIN_28;
		cfgPin1_28.Funcnum = PINSEL_FUNC_3;
		cfgPin1_28.Pinmode = PINSEL_PINMODE_TRISTATE;
		cfgPin1_28.OpenDrain = PINSEL_PINMODE_NORMAL;

		PINSEL_ConfigPin(&cfgPin1_28);

	//Configuro un pin PO.6 como de MATCH2[0]

	PINSEL_CFG_Type cfgPin0_6;

	cfgPin0_6.Portnum = PINSEL_PORT_0;
	cfgPin0_6.Pinnum = PINSEL_PIN_6;
	cfgPin0_6.Funcnum = PINSEL_FUNC_3;
	cfgPin0_6.Pinmode = PINSEL_PINMODE_TRISTATE;
	cfgPin0_6.OpenDrain = PINSEL_PINMODE_NORMAL;

	PINSEL_ConfigPin(&cfgPin0_6);

	//Configuro un pin P2.11 como de EINT1

	PINSEL_CFG_Type cfgPin2_11;

	cfgPin2_11.Portnum = PINSEL_PORT_2;
	cfgPin2_11.Pinnum = PINSEL_PIN_11;
	cfgPin2_11.Funcnum = PINSEL_FUNC_1;
	cfgPin2_11.Pinmode = PINSEL_PINMODE_PULLUP;
	cfgPin2_11.OpenDrain = PINSEL_PINMODE_NORMAL;

	PINSEL_ConfigPin(&cfgPin2_11);

	//Configuro un pin P2.10 como de EINT0

		PINSEL_CFG_Type cfgPin2_10;

		cfgPin2_10.Portnum = PINSEL_PORT_2;
		cfgPin2_10.Pinnum = PINSEL_PIN_10;
		cfgPin2_10.Funcnum = PINSEL_FUNC_1;
		cfgPin2_10.Pinmode = PINSEL_PINMODE_PULLUP;
		cfgPin2_10.OpenDrain = PINSEL_PINMODE_NORMAL;

		PINSEL_ConfigPin(&cfgPin2_10);


}

int cfgTimer0(void){

	//Configuro el TIM0
	TIM_TIMERCFG_Type cfgTimer0;
	TIM_MATCHCFG_Type cfgMatch0;

	cfgTimer0.PrescaleOption = TIM_PRESCALE_USVAL;
	cfgTimer0.PrescaleValue = 1000;

	cfgMatch0.MatchChannel=0;
	cfgMatch0.IntOnMatch=DISABLE;
	cfgMatch0.StopOnMatch= DISABLE;
	cfgMatch0.ResetOnMatch=ENABLE;
	cfgMatch0.ExtMatchOutputType=TIM_EXTMATCH_TOGGLE;
	cfgMatch0.MatchValue=200;

	TIM_Init(LPC_TIM0,TIM_TIMER_MODE, &cfgTimer0);
	TIM_ConfigMatch(LPC_TIM0, &cfgMatch0);
	TIM_Cmd(LPC_TIM0, ENABLE);

	return 0;
}
int cfgTimer2(uint32_t x){

	//Configuro el TIM2
	TIM_TIMERCFG_Type cfgTimer2;
	TIM_MATCHCFG_Type cfgMatch2;

	cfgTimer2.PrescaleOption = TIM_PRESCALE_USVAL;
	cfgTimer2.PrescaleValue = x;

	cfgMatch2.MatchChannel=0;
	cfgMatch2.IntOnMatch=DISABLE;
	cfgMatch2.StopOnMatch= DISABLE;
	cfgMatch2.ResetOnMatch=ENABLE;
	cfgMatch2.ExtMatchOutputType=TIM_EXTMATCH_TOGGLE;
	cfgMatch2.MatchValue=100;

	TIM_Init(LPC_TIM2,TIM_TIMER_MODE, &cfgTimer2);
	TIM_ConfigMatch(LPC_TIM2, &cfgMatch2);
	TIM_Cmd(LPC_TIM2, ENABLE);

	//NVIC_SetPriority(TIMER2_IRQn, 0);
	//NVIC_EnableIRQ(TIMER2_IRQn);

	return 0;
}

void cfgExtInt0(void){

	EXTI_InitTypeDef cfgEINT0;

	cfgEINT0.EXTI_Line = EXTI_EINT0;
	cfgEINT0.EXTI_Mode = EXTI_MODE_EDGE_SENSITIVE;
	cfgEINT0.EXTI_polarity = EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;

	EXTI_Init();
	EXTI_Config(&cfgEINT0);

	NVIC_SetPriority(EINT0_IRQn, 1);
	NVIC_EnableIRQ(EINT0_IRQn);

	return;
}

void cfgExtInt1(void){

	EXTI_InitTypeDef cfgEINT1;

	cfgEINT1.EXTI_Line = EXTI_EINT1;
	cfgEINT1.EXTI_Mode = EXTI_MODE_EDGE_SENSITIVE;
	cfgEINT1.EXTI_polarity = EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE;

	EXTI_Init();
	EXTI_Config(&cfgEINT1);

	NVIC_SetPriority(EINT1_IRQn, 2);
	NVIC_EnableIRQ(EINT1_IRQn);

	return;
}

void EINT0_IRQHandler(void){
	volatile uint32_t MatchActual = 200;

	MatchActual=MatchActual*2;

	TIM_Cmd(LPC_TIM0, DISABLE);
	TIM_UpdateMatchValue(LPC_TIM0, CANAL_MATCH_0, MatchActual);
	TIM_ResetCounter(LPC_TIM0);
	TIM_Cmd(LPC_TIM0, ENABLE);

	EXTI_ClearEXTIFlag(EXTI_EINT0);

}

void EINT1_IRQHandler(void){
	BaseDeTiempo = BaseDeTiempo*2;

	TIM_Cmd(LPC_TIM2, DISABLE);
	cfgTimer2(BaseDeTiempo);

	EXTI_ClearEXTIFlag(EXTI_EINT1);

}










